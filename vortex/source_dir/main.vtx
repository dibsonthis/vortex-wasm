// import io
// import math
// import sdl
// import [] : string
// import [] : logging
// import [msg] : "other"

// println(msg)

// const logger = Logger("SDL")
// logger.setBaseLogLevel(LogLevels.DEBUG)
// logger.setFilePath("sdl.debug")
// logger.setFormat("%name%: [%level%] %message% - %day%/%month%/%year%T%hh%:%mm%")

// const vec3 = (x = 0, y = 0, z = 0) => {
//     return {x: x, y: y, z: z}
// }

// const triangle = (a, b, c) => {
//     return {a: a, b: b, c: c}
// }

// const loadObject = (filePath) => {
//     const src = io.readf(filePath)
//     const lines = src.split("\n")

//     var vecs = []
//     var triangles = []

//     for (lines, i, line) {
//         if (line[0] == "v") {
//             const vecLine = line.split()
//             var vec = vec3(vecLine[1].number(), vecLine[2].number(), vecLine[3].number())
//             vecs.append(vec)
//         } else if (line[0] == "f") {
//             const fLine = line.split()
//             var tri = triangle(vecs[fLine[1].number() - 1], vecs[fLine[2].number() - 1], vecs[fLine[3].number() - 1])
//             triangles.append(tri)
//         }
//     }

//    return { triangles: triangles }
// }

// var init = sdl.initSDL()

// if (init != 0) {
//   print("Error initializing SDL\n")
//   exit(1)
// } else {
//   print("Initialized SDL\n")
// }

// const window = sdl.createWindow("Test", 300, 100, 600, 400)
// const renderer = sdl.createRenderer(window)

// var running = true
// var debug = false
// var xPos = 0
// var yPos = 0

// /* Game Vars */

// var cube = {}

// cube.triangles = [
//     // South
//     triangle(vec3(0, 0, 0), vec3(0, 1, 0), vec3(1, 1, 0)),
//     triangle(vec3(0, 0, 0), vec3(1, 1, 0), vec3(1, 0, 0)),

//     // East
//     triangle(vec3(1, 0, 0), vec3(1, 1, 0), vec3(1, 1, 1)),
//     triangle(vec3(1, 0, 0), vec3(1, 1, 1), vec3(1, 0, 1)),

//     // North
//     triangle(vec3(1, 0, 1), vec3(1, 1, 1), vec3(0, 1, 1)),
//     triangle(vec3(1, 0, 1), vec3(0, 1, 1), vec3(0, 0, 1)),

//     // West
//     triangle(vec3(0, 0, 1), vec3(0, 1, 1), vec3(0, 1, 0)),
//     triangle(vec3(0, 0, 1), vec3(0, 1, 0), vec3(0, 0, 0)),

//     // Top
//     triangle(vec3(0, 1, 0), vec3(0, 1, 1), vec3(1, 1, 1)),
//     triangle(vec3(0, 1, 0), vec3(1, 1, 1), vec3(1, 1, 0)),

//     // Bottom
//     triangle(vec3(1, 0, 1), vec3(0, 0, 1), vec3(0, 0, 0)),
//     triangle(vec3(1, 0, 1), vec3(0, 0, 0), vec3(1, 0, 0))
// ]

// // var object = loadObject("resources/spaceship.obj")
// var object = cube

// // Projection Matrix

// const fNear = 0.1
// const fFar = 1000
// const fFov = 100
// const fAspectRatio = sdl.getWindowSize(window).h / sdl.getWindowSize(window).w
// const fFovRad = 1 / math.tan(fFov * 0.5 / 180 * 3.14)
// var fTheta = 0

// var distance = 10
// var rotation_factor = 0.3

// var vCamera = { x: 0, y: 0, z: 0 }

// const matProj = [
//     [fAspectRatio * fFovRad, 0, 0, 0],
//     [0, fFovRad, 0, 0],
//     [0, 0, fFar / (fFar - fNear), 1],
//     [0, 0, (-fFar * fNear) / (fFar - fNear), 0]
// ]

// const multMat4 = (vec, mat) => {
//     var vecOut = math.multMat4(vec, mat)

//     // var vecOut = {
//     //     x: vec.x * mat[0][0] + vec.y * mat[1][0] + vec.z * mat[2][0] + mat[3][0],
//     //     y: vec.x * mat[0][1] + vec.y * mat[1][1] + vec.z * mat[2][1] + mat[3][1],
//     //     z: vec.x * mat[0][2] + vec.y * mat[1][2] + vec.z * mat[2][2] + mat[3][2]
//     // }

//     // const w = vec.x * mat[0][3] + vec.y * mat[1][3] + vec.z * mat[2][3] + mat[3][3]

//     // if (w != 0) {
//     //     vecOut.x = vecOut.x / w;
//     //     vecOut.y = vecOut.y / w;
//     //     vecOut.z = vecOut.z / w;
//     // }

//     return vecOut
// }

// const drawTriangle = (renderer, x1, y1, x2, y2, x3, y3, color) => {
//     sdl.setRenderDrawColor(renderer, color.r, color.g, color.b, color.a)
//     sdl.drawLine(renderer, x1, y1, x2, y2)
//     sdl.drawLine(renderer, x2, y2, x3, y3)
//     sdl.drawLine(renderer, x3, y3, x1, y1)
// }

// const fillTriangle = (renderer, x1, y1, x2, y2, x3, y3, color) => {
//     sdl.setRenderDrawColor(renderer, color.r, color.g, color.b, color.a)
//     sdl.drawGeometry(renderer, [
//         {color: color, position: vec3(x1, y1, 0)},
//         {color: color, position: vec3(x2, y2, 0)},
//         {color: color, position: vec3(x3, y3, 0)}
//     ])
// }

// const onQuit = () => {
//     logger.info("Quit SDL")
//   print("Done\n")
//   running = false
// }

// const onMouseDown = (event) => {
// }

// const onMouseUp = (event) => {
// }

// const onKeyDown = (event) => {
//   const keyStr = sdl.getKeyName(event.key.keysm.sym)
//   if (keyStr == "Escape") {
//     onQuit()
//   }
//     if (keyStr == "D") {
//         logger.info("Debug: " + string(debug))
//         debug = !debug
//     }
//     if (keyStr == "W") {
//         rotation_factor += 0.05
//     }
//     if (keyStr == "Q") {
//         rotation_factor -= 0.05
//     }
//     if (keyStr == "S") {
//         distance += 0.5
//     }
//     if (keyStr == "A") {
//         distance -= 0.5
//     }
// }

// const onKeyUp = (event) => {
// }

// const onMouseMotion = (event) => {
//   xPos = event.motion.x
//   yPos = event.motion.y
// }

// const main = () => {
//   var status;
//   while (status != 0) {
//       const poll = sdl.pollEvent()
//       status = poll.status
//       const event = poll.event

//       if (event.type == sdl.EventType.QUIT) {
//           onQuit()
//       }
//       if (event.type == sdl.EventType.MOUSEBUTTONDOWN) {
//         println("Clicked")
//         onMouseDown(event)
//       }
//       if (event.type == sdl.EventType.MOUSEBUTTONUP) {
//         onMouseUp(event)
//       }
//       if (event.type == sdl.EventType.MOUSEMOTION) {
//         onMouseMotion(event)
//       }
//       if (event.type == sdl.EventType.KEYDOWN) {
//         onKeyDown(event)
//       }
//       if (event.type == sdl.EventType.KEYUP) {
//         onKeyUp(event)
//       }
//     }

//     sdl.renderClear(renderer)

//   /* Render */

//   fTheta += rotation_factor

//   const matRotZ = [
//       [math.cos(fTheta), math.sin(fTheta), 0, 0],
//       [-math.sin(fTheta), math.cos(fTheta), 0, 0],
//       [0, 0, 1, 0],
//       [0, 0, 0, 1]
//   ]

//   const matRotX = [
//       [1, 0, 0, 0],
//       [0, math.cos(fTheta * 0.5), math.sin(fTheta * 0.5), 0],
//       [0, -math.sin(fTheta * 0.5), math.cos(fTheta * 0.5), 0],
//       [0, 0, 0, 1]
//   ]

//   var trianglesToRender = []

//   for (object.triangles, i, tri) {

//       var object_color = { r: 200, g: 0, b: 255, a: 255 }

//       var rotatedTri = copy(tri)

//       rotatedTri.a = multMat4(rotatedTri.a, matRotZ)
//       rotatedTri.b = multMat4(rotatedTri.b, matRotZ)
//       rotatedTri.c = multMat4(rotatedTri.c, matRotZ)

//       rotatedTri.a = multMat4(rotatedTri.a, matRotX)
//       rotatedTri.b = multMat4(rotatedTri.b, matRotX)
//       rotatedTri.c = multMat4(rotatedTri.c, matRotX)

//       var translatedTri = rotatedTri

//       translatedTri.a.z += distance
//       translatedTri.b.z += distance
//       translatedTri.c.z += distance

//       // Extract Normal

//       const line1 = {
//           x: translatedTri.b.x - translatedTri.a.x,
//           y: translatedTri.b.y - translatedTri.a.y,
//           z: translatedTri.b.z - translatedTri.a.z,
//       }

//       const line2 = {
//           x: translatedTri.c.x - translatedTri.a.x,
//           y: translatedTri.c.y - translatedTri.a.y,
//           z: translatedTri.c.z - translatedTri.a.z,
//       }

//       var normal = {
//           x: line1.y * line2.z - line1.z * line2.y,
//           y: line1.z * line2.x - line1.x * line2.z,
//           z: line1.x * line2.y - line1.y * line2.x,
//       }

//       // Normalise Normal

//       const l = math.sqrt((normal.x ^ 2) + (normal.y ^ 2) + (normal.z ^ 2))
//       normal.x = normal.x / l
//       normal.y = normal.y / l
//       normal.z = normal.z / l

//       const normal_dot_product = 
//           normal.x * (translatedTri.a.x - vCamera.x) +
//           normal.y * (translatedTri.a.y - vCamera.y) +
//           normal.z * (translatedTri.a.z - vCamera.z)

//       if (normal_dot_product < 0) {

//           // Basic light

//           var vLight = { x: 0, y: 0, z: -1 }

//           const lightNormaliser = math.sqrt((vLight.x ^ 2) + (vLight.y ^ 2) + (vLight.z ^ 2))
//           vLight.x = vLight.x / lightNormaliser
//           vLight.y = vLight.y / lightNormaliser
//           vLight.z = vLight.z / lightNormaliser

//           const light_dot_product = 
//           normal.x * (vLight.x - vCamera.x) +
//           normal.y * (vLight.y - vCamera.y) +
//           normal.z * (vLight.z - vCamera.z)

//           // Projection

//           var projectedTri = {
//               a: multMat4(translatedTri.a, matProj),
//               b: multMat4(translatedTri.b, matProj),
//               c: multMat4(translatedTri.c, matProj)
//           }

//           // Scale

//           projectedTri.a.x += 1
//           projectedTri.a.y += 1
//           projectedTri.b.x += 1
//           projectedTri.b.y += 1
//           projectedTri.c.x += 1
//           projectedTri.c.y += 1

//           projectedTri.a.x = projectedTri.a.x * 0.5 * sdl.getWindowSize(window).w
//           projectedTri.a.y = projectedTri.a.y * 0.5 * sdl.getWindowSize(window).h
//           projectedTri.b.x = projectedTri.b.x * 0.5 * sdl.getWindowSize(window).w
//           projectedTri.b.y = projectedTri.b.y * 0.5 * sdl.getWindowSize(window).h
//           projectedTri.c.x = projectedTri.c.x * 0.5 * sdl.getWindowSize(window).w
//           projectedTri.c.y = projectedTri.c.y * 0.5 * sdl.getWindowSize(window).h

//           projectedTri.color = {r: light_dot_product * object_color.r, g: light_dot_product * object_color.g, b: light_dot_product * object_color.b, a: 255}

//           trianglesToRender.append(projectedTri)
//       }
//   }

//   trianglesToRender = trianglesToRender.sort((t1, t2) => {
//       const z1 = (t1.a.z + t1.b.z + t1.c.z) / 3
//       const z2 = (t2.a.z + t2.b.z + t2.c.z) / 3
//       return z1 > z2
//   })

//   for (trianglesToRender, i, tri) {

//       fillTriangle(
//           renderer,
//           tri.a.x, tri.a.y,
//           tri.b.x, tri.b.y,
//           tri.c.x, tri.c.y,
//           tri.color
//       )

//       if (debug) {
//           drawTriangle(
//               renderer,
//               tri.a.x, tri.a.y,
//               tri.b.x, tri.b.y,
//               tri.c.x, tri.c.y,
//               {r: 255, g: 255, b: 255, a: 255}
//           )
//       }
//   }

//   sdl.setRenderDrawColor(renderer, 0, 0, 0, 255)

//   sdl.renderPresent(renderer)

//   //sdl.delay(20)
// }

// sdl.wasm_main_loop(main, true)

// println("Done")

import requests

println(requests)