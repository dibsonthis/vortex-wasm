import wasm
import math
import json
import random
import [forEach, map] : functional
import [substring, trim, split, replaceAll, contains, startsWith] : string

const uuid = () => {
    return string(math.abs(random.rand()))
}

const __script_event_stringify = "globalThis._event = JSON.stringify({
    type: e.type,
    clientX: e.clientX,
    clientY: e.clientY,
    ctrlKey: e.ctrlKey,
    altKey: e.altKey,
    shiftKey: e.shiftKey,
    x: e.x,
    y: e.y,
    fromElement: {
        id: e?.fromElement?.id
    },
    target: {
        value: e.target?.value
    },
    data: e.detail?.data
});"

const get_property = (obj, prop) => {
    var _prop = prop.split(".")
    if (_prop.length() == 1) {
        return obj[_prop[0]]
    }

    var value = obj;

    for (_prop, index, p) {
        p = p.trim()
        if ("0123456789".contains(p)) {
            p = number(p)
        }
        value = value[p]
    }

    return value
}

const set_prop_hook = (obj, prop, hook) => {
    var _prop = prop.split(".")
    if (_prop.length() == 1) {
        const currentOnChange = obj[_prop[0]].info().onChangeHook
        if (currentOnChange) {
            return obj[_prop[0]]::onChange((e) => {
                currentOnChange(e)
                hook(e)
            })
        }
        return obj[_prop[0]]::onChange((e) => hook(e))
    }

    var value = obj;
    var container = obj

    for (_prop, index, p) {
        p = p.trim()
        if ("0123456789".contains(p)) {
            p = number(p)
        }
        if (index == 0) {
            const currentOnChange = container[p].info().onChangeHook
            if (currentOnChange) {
                container[p]::onChange((e) => {
                    currentOnChange(e)
                    hook(e)
                })
            } else {
                container[p]::onChange((e) => hook(e))
            }
        }
        if (index < _prop.length() - 1) {
            container = value[p]
        }

        value = value[p]
    }

    const currentOnChange = container[_prop[_prop.length()-1]].info().onChangeHook

    if (currentOnChange) {
        return container[_prop[_prop.length()-1]]::onChange((e) => {
            currentOnChange(e)
            hook(e)
        })
    }

    return container[_prop[_prop.length()-1]]::onChange((e) => hook(e))
}

const emit_event = (target, name, content = "") => {
    const script = f`
        var customEvent = new CustomEvent('${name}', {
            detail: {
                data: "${content}"
            }
        });

        document.getElementById('${target.id}').dispatchEvent(customEvent);
        `
    wasm.run_script(script)
}

type element = (config = {}, parent = None) => {
    config.type or (config.type = "div")
    config.id or (config.id = "e_" + string(math.abs(random.rand())))

    var elem = {
        id: config.id,
        type: config.type,
        children: []
    }

    var script = f"var _elem = document.createElement('${config.type}');"
    for (config.info().keys, index, key) {
        if (key == "type") {
            continue;
        }
        if (key == "_type") {
            script += f"_elem.type = `${config[key]}`;"
            continue;
        }
        if (key == "_for") {
            script += f"_elem.setAttribute('for', `${config[key]}`);"
            continue;
        }
        if (key == "onClick") {
            elem.onClick = wasm.make_closure(config[key])
            script += f"_elem.onclick = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onClick}]);
            };"
            continue;
        }
        if (key == "onInput") {
            elem.onInput = wasm.make_closure(config[key])
            script += f"_elem.oninput = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onInput}]);
            };"
            continue;
        }
        if (key == "onChange") {
            elem.onChange = wasm.make_closure(config[key])
            script += f"_elem.onchange = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onChange}]);
            };"
            continue;
        }
        if (key == "onBlur") {
            elem.onBlur = wasm.make_closure(config[key])
            script += f"_elem.onblur = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onBlur}]);
            };"
            continue;
        }
        if (key == "onMouseEnter") {
            elem.onMouseEnter = wasm.make_closure(config[key])
            script += f"_elem.onmouseenter = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onMouseEnter}]);
            };"
            continue;
        }
        if (key == "onMouseLeave") {
            elem.onMouseEnter = wasm.make_closure(config[key])
            script += f"_elem.onmouseleave = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onMouseLeave}]);
            };"
            continue;
        }
        if (key == "onMouseOver") {
            elem.onMouseEnter = wasm.make_closure(config[key])
            script += f"_elem.onmouseover = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onMouseOver}]);
            };"
            continue;
        }
        if (key == "onMouseMove") {
            elem.onMouseEnter = wasm.make_closure(config[key])
            script += f"_elem.onmousemove = function(e) {
                ${__script_event_stringify}
                Module.ccall('vortex_eval','void',['number'],[${elem.onMouseMove}]);
            };"
            continue;
        }
        if (key == "style") {
            if (config[key].type() != "Object") {
                continue;
            }
            for (config[key].info().keys, i, k) {
                script += f"_elem.style.${k} = `${config[key][k]}`;"
            }
            continue;
        }
        if (key == "children") {
            // We need to deal with children AFTER this element has been created
            continue;
        }
        script += f"_elem.${key} = `${config[key]}`;"
    }

    if (parent) {
        script += f"document.getElementById(`${parent.id}`).appendChild(_elem);"
    } else {
        script += "document.body.appendChild(_elem);"
    }

    wasm.run_script(script)

    if (config.children) {

        elem.children = []

        if (type(config.children) == "Object") {
            if (config.children.info().typename == "element") {
                wasm.run_script(f"document.getElementById(`${elem.id}`).appendChild(document.getElementById(`${config.children.id}`));")
                elem.children.append(config.children)
            } else {
                var child = element(config.children, elem)
                elem.children.append(child)
            }
        } else if (type(config.children) == "List") {
            for (config.children, i, _child) {
                if (_child.info().typename == "element") {
                    wasm.run_script(f"document.getElementById(`${elem.id}`).appendChild(document.getElementById(`${_child.id}`));")
                    elem.children.append(_child)
                } else {
                    var child = element(_child, elem)
                    elem.children.append(child)
                }
            }
        }
    }

    return {
        ...elem,
        update: (data) => {

            // See if this element exists in the DOM
            var exists = wasm.run_script_number(f`document.getElementById('${this.id}') !== null`)
            if (exists == 0) {
                return;
            }

            if (data.type() != "Object") {
                return;
            }

            // Force onChange hook to mimic an actual change in value
            this.info().onChangeHook and this.info().onChangeHook({old: {}, current: data})
            if (this.__inner_hook) {
                this.__inner_hook.info().onChangeHook and this.__inner_hook.info().onChangeHook({old: {}, current: data})
            }
            var script = f"
            var _elem = document.getElementById('${this.id}');
            "
            for (data.info().keys, index, key) {
                if (key == "type") {
                    continue;
                }
                if (key == "_type") {
                    script += f"_elem.type = `${data[key]}`;"
                    continue;
                }
                if (key == "_for") {
                    script += f"_elem.setAttribute('for', `${data[key]}`);"
                    continue;
                }
                if (key == "onClick") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onClick) {
                        wasm.delete_closure(this.onClick)
                    }
                    this.onClick = wasm.make_closure(data[key])
                    script += f"_elem.onclick = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onClick}]);
                    };"
                    continue;
                }
                if (key == "onInput") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onInput) {
                        wasm.delete_closure(this.onInput)
                    }
                    this.onInput = wasm.make_closure(data[key])
                    script += f"_elem.oninput = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onInput}]);
                    };"
                    continue;
                }
                if (key == "onChange") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onChange) {
                        wasm.delete_closure(this.onChange)
                    }
                    this.onChange = wasm.make_closure(data[key])
                    script += f"_elem.onchange = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onChange}]);
                    };"
                    continue;
                }
                if (key == "onBlur") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onBlur) {
                        wasm.delete_closure(this.onBlur)
                    }
                    this.onBlur = wasm.make_closure(data[key])
                    script += f"_elem.onblur = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onBlur}]);
                    };"
                    continue;
                }
                if (key == "onMouseEnter") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onMouseEnter) {
                        wasm.delete_closure(this.onMouseEnter)
                    }
                    this.onMouseEnter = wasm.make_closure(data[key])
                    script += f"_elem.onmouseenter = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onMouseEnter}]);
                    };"
                    continue;
                }
                if (key == "onMouseLeave") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onMouseLeave) {
                        wasm.delete_closure(this.onMouseLeave)
                    }
                    this.onMouseLeave = wasm.make_closure(data[key])
                    script += f"_elem.onmouseleave = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onMouseLeave}]);
                    };"
                    continue;
                }
                if (key == "onMouseOver") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onMouseOver) {
                        wasm.delete_closure(this.onMouseOver)
                    }
                    this.onMouseOver = wasm.make_closure(data[key])
                    script += f"_elem.onmouseover = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onMouseOver}]);
                    };"
                    continue;
                }
                if (key == "onMouseMove") {
                    if (!data[key]) {
                        continue
                    }
                    if (this.onMouseMove) {
                        wasm.delete_closure(this.onMouseMove)
                    }
                    this.onMouseMove = wasm.make_closure(data[key])
                    script += f"_elem.onmousemove = function(e) {
                        ${__script_event_stringify}
                        Module.ccall('vortex_eval','void',['number'],[${this.onMouseMove}]);
                    };"
                    continue;
                }
                if (key == "style") {
                    if (data[key].type() != "Object") {
                        continue;
                    }
                    for (data[key].info().keys, i, k) {
                        script += f"_elem.style.${k} = `${data[key][k]}`;"
                    }
                    continue;
                }
                if (key == "children") {
                    // We need to deal with children AFTER this element has been created
                    continue;
                }
                script += f"_elem.${key} = `${data[key]}`;"
            }

            wasm.run_script(script);

            if (data.children) {

                this.children = []

                const remove_children = f"
                var _elem = document.getElementById(`${this.id}`);
                while (_elem.firstChild) {
                    _elem.removeChild(_elem.firstChild);
                }
                "

                wasm.run_script(remove_children)

                if (type(config.children) == "Object") {
                    if (data.children.info().typename == "element") {
                        wasm.run_script(f"document.getElementById(`${this.id}`).appendChild(document.getElementById(`${data.children.id}`));")
                        this.children.append(data.children)
                    } else {
                        var child = element(data.children, this)
                        this.children.append(child)
                    }
                } else if (type(data.children) == "List") {
                    for (data.children, i, _child) {
                        if (_child.info().typename == "element") {
                            wasm.run_script(f"document.getElementById(`${this.id}`).appendChild(document.getElementById(`${_child.id}`));")
                            this.children.append(_child)
                        } else {
                            var child = element(_child, this)
                            this.children.append(child)
                        }
                    }
                }
            }

            return this;
        }
    }
}

const fetch = {
    get: wasm.fetch_get
}

const createCSSClass = (className, css) => {
    const _id = "style_" + string(math.abs(random.rand()))
    var script = f"var ${_id} = document.createElement('style');"
    script += f"${_id}.type = 'text/css';"
    script += f"${_id}.innerHTML = '.${className} { ${css} }';"
    script += f"document.head.appendChild(${_id});"

    wasm.run_script(script)
}

const addCSSClass = (id, className) => {
    wasm.run_script(f"document.getElementById('${id}').classList.add('${className}');")
}

const removeCSSClass = (id, className) => {
    wasm.run_script(f"document.getElementById('${id}').classList.remove('${className}');")
}

const value = (element) => {
    return wasm.run_script_string(f"document.getElementById(`${element.id}`).value")
}

const text = (element) => {
    return wasm.run_script_string(f"document.getElementById(`${element.id}`).innerText")
}

const event = () => {
    return json.parse(wasm.run_script_string(f"globalThis._event;"))
}


const attribute = (element, attr) => {
    return wasm.run_script_string(f"document.getElementById(`${element.id}`).${attr}")
}

const click = (element) => {
    return wasm.run_script(f"document.getElementById(`${element.id}`).click()")
}

const scrollToTop = () => {
    wasm.run_script("window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });")
}

/* Helper Types */

const div = (config) => element({
    type: "div",
    ...config
})

const p = (config) => element({
    type: "p",
    ...config
})

const span = (config) => element({
    type: "span",
    ...config
})

const h1 = (config) => element({
    type: "h1",
    ...config
})

const h2 = (config) => element({
    type: "h2",
    ...config
})

const h3 = (config) => element({
    type: "h3",
    ...config
})

const h4 = (config) => element({
    type: "h4",
    ...config
})

const h5 = (config) => element({
    type: "h5",
    ...config
})

const img = (config) => element({
    type: "img",
    ...config
})

const button = (config) => element({
    type: "button",
    ...config
})

const input = (config) => element({
    type: "input",
    ...config
})

const label = (config) => element({
    type: "label",
    ...config
})

const form = (config) => element({
    type: "form",
    ...config
})

/* Reactivity */

const ref = (value) => {
    return {
        value: value
    }
}

const appendOnChange = (_ref, hook) => {
    const currentHook = _ref.value.info().onChangeHook
    if (currentHook) {
        _ref.value::onChange((e) => {
            currentHook(e)
            hook(e)
        })
        return _ref
    }
    _ref.value::onChange(hook)
    return _ref
}

const appendOnChangeEx = (_ref, hook) => {
    if (!_ref.__inner_hook) {
        _ref.__inner_hook = 0
    }

    const currentHook = _ref.__inner_hook.info().onChangeHook
    if (currentHook) {
        _ref.__inner_hook::onChange((e) => {
            currentHook(e)
            hook(e)
        })
        return _ref
    }
    _ref.__inner_hook::onChange(hook)
    return _ref
}

const reactive = (config: Config, fn: (data) => Config, _ref: Ref | Element) => {
    var e = element(config)
    if (_ref.info().typename == "element") {
        _ref.appendOnChangeEx((data) => {
            e.update(fn(data.current))
        })
        return e
    }
    _ref.appendOnChange((data) => {
        e.update(fn(data.current))
    })
    return e
}

const react = (el: Element, _ref: Ref | Element, fn: (data) => Config) => {
    if (_ref.info().typename == "element") {
        _ref.appendOnChangeEx((e) => {
            el.update(fn(e.current))
        })
        return el
    }
    _ref.appendOnChange((e) => {
        el.update(fn(e.current))
    })
    return el
}

/* Templating */

const is_whitespace = (c) => {
    return c == "" or c == " " or c == "\n" or c == "\t"
}

const parseHTML = (html) => {
    var index = 0
    var tags = []

    while (index < html.length()) {
        if (html[index] == "<" and html[index + 1] == "!") {
            // comment
            while (!(html[index] == "-" and html[index + 1] == ">")) {
                index += 1
            }
            index += 2
        }
        if (html[index] == "<") {
            // Start of a tag
            var tag = {}
            var tagStart = index;
            var whitespace_index;
            var whitespace_chars_count = 0
            var reached_tag_name = false
            var end_tag_index;
            while (html[index] != ">") {
                index += 1;
                if (html[index] == " " and !whitespace_index) {
                    whitespace_index = index
                }

                if (!html[index].is_whitespace() and html[index] != "/") {
                    reached_tag_name = true
                }
                
                if (!reached_tag_name) {
                    whitespace_chars_count += 1
                }

                if (!end_tag_index and reached_tag_name and html[index].is_whitespace()) {
                    end_tag_index = index
                }
            }

            if (!whitespace_index) {
                whitespace_index = index
            }
            if (!end_tag_index) {
                end_tag_index = index
            }
            
            const tagName = html.substring(tagStart, index - tagStart + 1)
            const tagNameShort = html.substring(tagStart + whitespace_chars_count + 1, end_tag_index - (tagStart + whitespace_chars_count + 1))
            tag.name = tagNameShort
            tag.type = tagName;
            tag.is_start = (tagName[1] != "/")

            if (html[index-1] == "/") {
                tag.self_ending = true
                if (tag.name[tag.name.length()-1] == "/") {
                    tag.name = tag.name.substring(0, tag.name.length() - 1)
                }
            }

            tags.append(tag)
        } else if (html[index] == ">") {
            // End of a tag
            index += 1;
            continue;
        } else {
            // Text data
            var textStart = index;
            while (true) {
                if (index > html.length()) {
                    break
                }
                if (html[index] == "<") {
                    if (tags[tags.length()-1] and tags[tags.length()-1].name == "script") {
                        if (html[index + 1] == "/") {
                            break
                        } else {
                            index += 1
                            continue
                        }
                    }
                    break
                }
                index += 1;
            }
            // Output the text
            var content = html.substring(textStart, index - textStart).trim()
            if (content != "") {
                tags[tags.length()-1].content = content
            }
            continue;
        }
        index += 1;
    }

    return tags
}

const verifyHTML = (elements) => {
    var element_map = {}

    elements.forEach((element) => {
        if (element.self_ending) {
            return
        } else if (element.is_start) {
            element_map[element.name] and (element_map[element.name] += 1) or (element_map[element.name] = 1)
        } else {
            if (!element_map[element.name]) {
                error(f"Missing opening <${element.name}> tag")
            }
            element_map[element.name] -= 1
        }
    })
    
    for (element_map.info().keys, index, key) {
        if (element_map[key] > 0) {
            error(f"Missing closing </${key}> tag")
        }
    }
}

const alpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

const extractProperties = (elem) => {
    if (!elem.is_start) {
        return {
            id: None,
            events: {},
            styles: {},
            props: {},
            inner: {}
        }
    }
    var index = 0
    var _id = None;
    var events = {
        _dynamic: [],
        _dynamic_raw: {},
    }
    var styles = {
        _dynamic: [],
        _dynamic_raw: {},
    }
    var props = {
        _dynamic: [],
        _dynamic_raw: {},
    }
    var inner = {
        _dynamic: [],
        _dynamic_raw: {},
    }
    const elem_type = elem.type.substring(1, elem.type.length()).trim().substring(elem.name.length(), elem.type.length())
    while (elem_type[index]) {
        if (elem_type[index] == "#") {
            _id = ""
            index += 1
            while (true) {
                if (elem_type[index].is_whitespace() or elem_type[index] == ">") {
                    break;
                }
                _id += elem_type[index]
                index += 1
            }
        }

        else if (elem_type[index] == "@") {
            index += 1
            var event_type = ""
            var func_name = ""
            while (elem_type[index] != ":" and elem_type[index] != "=") {
                event_type += elem_type[index]
                index += 1
                if (!elem_type[index] or elem_type[index] == ">") {
                    error("Malformed @ handler")
                }
            }
            index += 1
            var hit_first_letter = false
            var is_quote = false
            var is_dynamic = false
            while (true) {
                if (!elem_type[index].is_whitespace()) {
                    hit_first_letter = true
                }

                if (elem_type[index].is_whitespace() and !hit_first_letter) {
                    index += 1
                    continue
                }

                if (elem_type[index].is_whitespace() or elem_type[index] == ">") {
                    break;
                }

                if (elem_type[index] == "\"") {
                    is_quote = true
                    index += 1
                    while (true) {
                        if (elem_type[index] == "\"") {
                            index += 1
                            break
                        }
                        func_name += elem_type[index]
                        index += 1
                    }
                }

                if (elem_type[index] == "{" and elem_type[index + 1] == "{") {
                    is_dynamic = true
                    index += 2
                    while (true) {
                        if (elem_type[index] == "}" and elem_type[index + 1] == "}") {
                            index += 2
                            break
                        }
                        func_name += elem_type[index]
                        index += 1
                    }
                }

                if (is_quote or is_dynamic) {
                    break
                }

                func_name += elem_type[index]
                index += 1
            }
            events[event_type.trim()] = func_name.trim()
            if (is_dynamic) {
                events["_dynamic"].append(event_type.trim())
            }
        }

        else if (elem_type[index] == "$") {
            index += 1
            var style_type = ""
            var style_value = ""
            while (elem_type[index] != ":" and elem_type[index] != "=") {
                style_type += elem_type[index]
                index += 1
                if (!elem_type[index] or elem_type[index] == ">") {
                    error("Malformed $ handler")
                }
            }
            index += 1
            var hit_first_letter = false
            var is_quote = false
            var is_dynamic = false
            while (true) {
                if (!elem_type[index].is_whitespace()) {
                    hit_first_letter = true
                }

                if (elem_type[index].is_whitespace() and !hit_first_letter) {
                    index += 1
                    continue
                }

                if (elem_type[index].is_whitespace() or elem_type[index] == ">") {
                    break;
                }

                if (elem_type[index] == "\"") {
                    is_quote = true
                    index += 1
                    while (true) {
                        if (elem_type[index] == "\"") {
                            index += 1
                            break
                        }
                        style_value += elem_type[index]
                        index += 1
                    }
                }

                if (elem_type[index] == "{" and elem_type[index + 1] == "{") {
                    is_dynamic = true
                    index += 2
                    while (true) {
                        if (elem_type[index] == "}" and elem_type[index + 1] == "}") {
                            index += 2
                            break
                        }
                        style_value += elem_type[index]
                        index += 1
                    }
                }

                if (is_quote or is_dynamic) {
                    break
                }

                style_value += elem_type[index]
                index += 1
            }
            styles[style_type.trim()] = style_value.trim()
            if (is_dynamic) {
                styles["_dynamic"].append(style_type.trim())
            }
        }

        else if (elem_type[index] == "%") {
            index += 1
            var inner_type = ""
            var inner_value = ""
            while (elem_type[index] != ":" and elem_type[index] != "=") {
                inner_type += elem_type[index]
                index += 1
                if (!elem_type[index] or elem_type[index] == ">") {
                    error("Malformed $ handler")
                }
            }
            index += 1
            var hit_first_letter = false
            var is_quote = false
            var is_dynamic = false
            while (true) {
                if (!elem_type[index].is_whitespace()) {
                    hit_first_letter = true
                }

                if (elem_type[index].is_whitespace() and !hit_first_letter) {
                    index += 1
                    continue
                }

                if (elem_type[index].is_whitespace() or elem_type[index] == ">") {
                    break;
                }

                if (elem_type[index] == "\"") {
                    is_quote = true
                    index += 1
                    while (true) {
                        if (elem_type[index] == "\"") {
                            index += 1
                            break
                        }
                        inner_value += elem_type[index]
                        index += 1
                    }
                }

                if (elem_type[index] == "{" and elem_type[index + 1] == "{") {
                    is_dynamic = true
                    index += 2
                    while (true) {
                        if (elem_type[index] == "}" and elem_type[index + 1] == "}") {
                            index += 2
                            break
                        }
                        inner_value += elem_type[index]
                        index += 1
                    }
                }

                if (is_quote or is_dynamic) {
                    break
                }

                inner_value += elem_type[index]
                index += 1
            }
            inner[inner_type.trim()] = inner_value.trim()
            if (is_dynamic) {
                inner["_dynamic"].append(inner_type.trim())
            }
        }

        else if (elem_type[index] == "/" and elem_type[index + 1] == "/") {
            while (true) {
                if (elem_type[index] == "\n") {
                    index += 1
                    break
                }
                if (!elem_type[index] or elem_type[index] == ">") {
                    error("Malformed comment")
                }
                index += 1
            }
        }

        else if (alpha.contains(elem_type[index]) or elem_type[index] == "_") {
            var prop_name = ""
            var prop_value = ""
            while (elem_type[index] != ":" and elem_type[index] != "=") {
                prop_name += elem_type[index]
                index += 1
                if (!elem_type[index] or elem_type[index] == ">") {
                    error("Malformed property")
                }
            }
            index += 1
            var hit_first_letter = false
            var is_quote = false
            var is_dynamic = false
            while (true) {
                if (!elem_type[index].is_whitespace()) {
                    hit_first_letter = true
                }

                if (elem_type[index].is_whitespace() and !hit_first_letter) {
                    index += 1
                    continue
                }

                if (elem_type[index].is_whitespace() or elem_type[index] == ">") {
                    break;
                }

                if (elem_type[index] == "\"") {
                    is_quote = true
                    index += 1
                    while (true) {
                        if (elem_type[index] == "\"") {
                            index += 1
                            break
                        }
                        prop_value += elem_type[index]
                        index += 1
                    }
                }

                if (elem_type[index] == "{" and elem_type[index + 1] == "{") {
                    is_dynamic = true
                    index += 2
                    while (true) {
                        if (elem_type[index] == "}" and elem_type[index + 1] == "}") {
                            index += 2
                            break
                        }
                        prop_value += elem_type[index]
                        index += 1
                    }
                }

                if (is_quote or is_dynamic) {
                    break
                }

                prop_value += elem_type[index]
                index += 1
            }
            props[prop_name.trim()] = prop_value.trim()
            if (is_dynamic) {
                props["_dynamic"].append(prop_name.trim())
            }
        }

        index += 1
    }

    return {
        id: _id,
        events: events,
        styles: styles,
        props: props,
        inner: inner
    }
}

const with_hook = (data, hook, name = "data") => {
    if (data.type() != "Object") {
        return data::onAccess((e) => hook(e), name)
    }

    var _data = {}

    for (data.info().keys, index, key) {
        _data[key] = with_hook(data[key], hook, name + "." + key)
    }

    return _data::onAccess((e) => hook(e), name)
}

const parseContent = (content, data = {}) => {

    if (!content) {
        return {
            variables: [],
            content: ""
        }
    }

    var index = 0
    var variables = []
    var substrings = []
    var new_content = content;
    var diff = 0

    while (content[index]) {
        if (content[index] == "{" and content[index + 1] == "{") {
            var start_index = index
            var end_index = index
            var variable = ""
            index += 2
            while (true) {
                if (content[index] == "}" and content[index + 1] == "}") {
                    index += 2
                    end_index = index
                    break
                }
                if (!content[index]) {
                    error("Missing }} in template variable")
                }
                variable += content[index]
                index += 1
            }

            // variable = variable.trim().split(" ");
            // if (variable.length() != 1) {
            //     error("Template variables must contain one value")
            // }
            // variable = variable[0]
            const substr = new_content.substring(start_index, end_index - start_index)
            substrings.append(substr)
            variables.append(variable.trim())
        }
        index += 1
    }

    variables.forEach((var, i) => {
        // new_content = new_content.replaceAll(substrings[i], string(data[var]))
        new_content = new_content.replaceAll(substrings[i], string(eval(var, data)))
    })

    return {
        variables: variables,
        content: new_content
    }
}

const new_element = (tag, data, dep, config, is_custom, components, props, collecting_for_children) => {
    var dependencies = []
    if (tag.content) {
        const data = with_hook(data, (e) => {
            var name = e.name
            if (name.startsWith("data.")) {
                name = name.replaceAll("data.", "")
            }
            if (dep) {
                dep.append(name)
            } else {
                dep = [name]
            }
        })

        if (!collecting_for_children) {
            const parsed_content = tag.content.parseContent(data)
            config.innerHTML = parsed_content.content
            dependencies = dep and dep or []
        }
    }

    var e;

    if (is_custom) {
        const comp = components[tag.name]
        if (!comp) {
            println(f"Warning: No such component '${tag.name}'")
        } else {
            e = comp(props.props, data)
        }
    } else {
       e = element(config)
    }

    e._data = {...data}

    return {
        element: e,
        dependencies: dependencies
    }
}

const createElement = (html, data = {}, methods = (data) => ({}), custom = {}, components = {}) => {

    // if (!data.__id) {
    //     data.__id = uuid()
    // }

    var looped_elements = []

    data.props = custom

    methods = methods(data)

    var tags;

    if (html.type() == "String") {
        tags = parseHTML(html)
        verifyHTML(tags)
    } else {
        tags = html
    }

    if (methods.setup) {
        methods.setup()
    }

    // We need the parent data merged in
    // So that we can more naturally put dynamic props in the parent
    // When creating a custom element
    // ie: <CustonElement title: {{ title }} />
    // title is evaluated here, inside the custom component, not in the parent
    // So to avoid something ugly like: <CustonElement title: {{ __parent.title }} />
    // we merge the parent data in for the props evaluation
    const __data_parent_merged = {...data, ...data.__parent}

    // Eval the props coming in
    if (data.props.info().keys.length() > 0) {
        data.props._dynamic.forEach((val, index) => {
            if (data.props[val].type() != "String") {
                return
            }
            data.props._dynamic_raw[val] = data.props[val]
            // println(val)
            // println(__data_parent_merged)
            data.props[val] = eval(data.props[val], __data_parent_merged)
            if (data.__parent[val]) {
                data.__parent[val]::onChange((e) => {
                    if (data[val]) {
                        data[val] = e.current
                        if (methods.init) {
                            methods.init()
                        }
                    }
                })
            }
        })
    }

    var stack = []
    var parent;
    var parent_exists = false;

    var customElementStack = []

    var deps = {}

    var collecting_for_children = false

    if (methods.before) {
        methods.before()
    }

    tags.forEach((tag, i) => {

        if (collecting_for_children) {
            looped_elements[looped_elements.length()-1].children.append(tag)
        }

        var is_custom = upper.contains(tag.name[0])
        const props = tag.extractProperties();
        const _id = props.id;
        var dependencies = []

        if (tag.is_start) {
            var config = {
                type: tag.name
            }

            var elem = new_element(tag, data, deps[string(i)], config, is_custom, components, props, collecting_for_children)
            dependencies = elem.dependencies
            var e = elem.element

            if (_id) {
                wasm.run_script(f`document.getElementById("${e.id}").id = "${_id}";`)
                e.id = _id
            }

            deps[string(i)] = []

            if (tag.name == "style") {
                return
            }

            if (tag.name == "script") {
                return
            }

            if (tag.name == "children") {
                if (parent._children_section) {
                    println("Warning - only one children section allowed")
                } else {
                    parent._children_section = e
                }
            }

            if (stack.length() == 0) {
                if (parent_exists) {
                    error("Only one parent allowed", "TemplateError")
                }
                parent = e
                parent_exists = true
            } else {
                if (customElementStack.length() > 0) {
                    // We have a custom element on the stack
                    // We want to append children into it
                    // But only in the children slot
                    var last_stack_elem = customElementStack[customElementStack.length() - 1]
                    last_stack_elem.children.append(e)
                    // If the element's _children_section doesn't exist
                    // We append to the end
                    if (last_stack_elem._children_section) {
                        wasm.run_script(f"document.getElementById(`${last_stack_elem._children_section.id}`).appendChild(document.getElementById(`${e.id}`));")
                        _id and (last_stack_elem._children_section[_id] = e)
                    } else {
                        wasm.run_script(f"document.getElementById(`${last_stack_elem.id}`).appendChild(document.getElementById(`${e.id}`));")
                        _id and (last_stack_elem[_id] = e)
                        }
                } else {
                    var last_stack_elem = stack[stack.length() - 1]
                    last_stack_elem.children.append(e)
                    wasm.run_script(f"document.getElementById(`${last_stack_elem.id}`).appendChild(document.getElementById(`${e.id}`));")
                    if (_id) {
                        last_stack_elem[_id] = e
                        // We'll add it to the flat list of named elements in the root so that it's easier to get to as well
                        if (parent._named) {
                            parent._named[_id] = e
                        } else {
                            parent._named = {}
                            parent._named[_id] = e
                        }
                    }
                }
            }

            // We apply an onChange hook here so that whenever these variables change
            // It updates the corresponding element

            var _data = data

            // We don't want to add dependencies here if it's a "for" element
            // Because we delete this later and won't exist in the DOM

            if (!props.inner["for"]) {
                dependencies.forEach((var) => {
                    set_prop_hook(data, var, (_e) => {
                        if (e._data) {
                            _data = {...e._data, ...data}
                        }
                        const parsed_content = tag.content.parseContent(_data)
                        e.update({
                            innerHTML: parsed_content.content
                        })
                    })
                })
            }

            // If we have styles, we apply them here
            // Let's update the values for dynamic styles first

            var deps = []

            if (!collecting_for_children) {

                var style_data = with_hook(data.copy(), (e) => {
                    var name = e.name
                    if (name.startsWith("data.")) {
                        name = name.replaceAll("data.", "")
                    }
                    deps.append(name)
                })

                for (props.styles._dynamic, index, val) {
                    props.styles._dynamic_raw[val] = props.styles[val]
                    props.styles[val] = eval(props.styles[val], style_data)
                }

                e.update({
                    style: props.styles
                })

                // Handle dynamic events by making them a function

                for (props.events._dynamic, index, val) {
                    const s = props.events[val]
                    var fn;
                    if (e._data) {
                        fn = () => eval(f`${s}`, {...data, ...e._data})
                    } else {
                        fn = () => eval(f`${s}`, data)
                    }
                    props.events[val] = fn
                }

                // If we have events, we apply them here
                props.events.info().keys.forEach((key) => {
                    const method_value = props.events[key]
                    var method;
                    if (method_value.type() == "String") {
                        method = methods[method_value]
                    } else {
                        method = method_value
                    }
                    var injected_method = method

                    if (method.info().arity == 1) {
                        // Inject the parent here
                        injected_method = () => method(parent)
                    }
                    if (!method) {
                        println(f"No such method '${method_name}'")
                        return
                    }
                    if (key == "input") {
                        e.update({
                            onInput: injected_method
                        })
                    } else if (key == "click") {
                        e.update({
                            onClick: injected_method
                        })
                    } else if (key == "click_self") {
                        e.onClick = wasm.make_closure(injected_method)
                        const script = f`
                            const element = document.getElementById('${e.id}');
                            element.onclick = function(e) {
                                ${__script_event_stringify}
                                if (e.target == element) {
                                    Module.ccall('vortex_eval','void',['number'],[${e.onClick}]);
                                }
                            };
                        `
                        wasm.run_script(script)
                    } else if (key == "blur") {
                        e.update({
                            onBlur: injected_method
                        })
                    } else if (key == "change") {
                        e.update({
                            onChange: injected_method
                        })
                    } else if (key == "enter") {
                        e.update({
                            onMouseEnter: injected_method
                        })
                    } else if (key == "leave") {
                        e.update({
                            onMouseLeave: injected_method
                        })
                    } else if (key == "over") {
                        e.update({
                            onMouseOver: injected_method
                        })
                    } else if (key == "move") {
                        e.update({
                            onMouseMove: injected_method
                        })
                    } else {
                        // Add a custom event listener
                        e[key] = wasm.make_closure(injected_method)
                        wasm.run_script(f`
                            document.getElementById("${e.id}").addEventListener("${key}", function(e) {
                            ${__script_event_stringify}
                            Module.ccall('vortex_eval','void',['number'],[${e[key]}]);
                        });`)
                    }
                })

                // If we have props, we apply them here

                deps = []

                var prop_data = with_hook(data.copy(), (e) => {
                    var name = e.name
                    if (name == "data") {
                        return
                    }
                    if (name.startsWith("data.")) {
                        name = name.replaceAll("data.", "")
                    }
                    deps.append(name)
                })

                for (props.props._dynamic, index, val) {
                    if (props.props[val].type() != "String") {
                        continue
                    }
                    props.props._dynamic_raw[val] = props.props[val]
                    props.props[val] = eval(props.props[val], prop_data)
                }

                if (props.props) {
                    e.update(props.props)
                }

                // If we have inner events, we apply them here

                deps = []

                var inner_data = with_hook(data.copy(), (e) => {
                    var name = e.name
                    if (name == "data") {
                        return
                    }
                    if (name.startsWith("data.")) {
                        name = name.replaceAll("data.", "")
                    }
                    deps.append(name)
                })

                for (props.inner._dynamic, index, val) {
                    props.inner._dynamic_raw[val] = props.inner[val]
                    props.inner[val] = eval(props.inner[val], inner_data)
                }

                props.inner.info().keys.forEach((key) => {
                    const value = props.inner[key]
                    if (key == "if") {
                        if (value.type() == "String") {
                            var predicate = data[value]
                            const predicateOnChange = predicate.info().onChangeHook
                            if (!predicate) {
                                e.update({
                                    style: {
                                        display: "none"
                                    }
                                })
                            }
                            if (predicateOnChange) {
                                data[value]::onChange((info) => {
                                    predicateOnChange(info)
                                    if (info.current) {
                                        e.update({
                                            style: {
                                                display: ""
                                            }
                                        })
                                    } else {
                                        e.update({
                                            style: {
                                                display: "none"
                                            }
                                        })
                                    }
                                })
                            } else {
                                data[value]::onChange((info) => {
                                    if (info.current) {
                                        e.update({
                                            style: {
                                                display: ""
                                            }
                                        })
                                    } else {
                                        e.update({
                                            style: {
                                                display: "none"
                                            }
                                        })
                                    }
                                })
                            }
                        } else {
                            if (!value) {
                                e.update({
                                    style: {
                                        display: "none"
                                    }
                                })
                            }

                            deps.forEach((dep_val, dep_index) => {
                                set_prop_hook(data, dep_val, (info) => {
                                    if (e._data) {
                                        _data = {...e._data, ...inner_data}
                                    }

                                    _data[dep_val] = info.current

                                    var res = eval(props.inner._dynamic_raw[key], _data)
                                    
                                    if (res) {
                                        e.update({
                                            style: {
                                                display: ""
                                            }
                                        })
                                    } else {
                                        e.update({
                                            style: {
                                                display: "none"
                                            }
                                        })
                                    }
                                })
                            })
                        }
                    }
                    if (key == "for") {
                        // println("FOUND FOR - ", i)
                        collecting_for_children = true
                        e.__is_for = true
                        var value = props.inner[key]
                        if (value.trim() == "") {
                            error("Malformed for loop")
                        }
                        var values = value.split(",").map((e) => e.trim())
                        var current_parent = stack[stack.length() - 1]

                        var t = tag
                        t.type = t.type.replaceAll("%for", "%__for")

                        looped_elements.append({
                            element: e,
                            tag: tag,
                            values: values,
                            current_parent: current_parent,
                            children: [t]
                        })  
                    }
                })
            }

            if (!tag.self_ending and is_custom) {
                e.customName = tag.name
                customElementStack.append(e)
            }
            
            if (!tag.self_ending and !is_custom) {
                stack.append(e)
            }
        } else {
            if (tag.name == "style") {
                return
            }

            if (tag.name == "script") {
                return
            }

            if (is_custom) {
                var last_stack_elem = customElementStack[customElementStack.length() - 1]
                if (tag.name == last_stack_elem.customName) {
                    customElementStack.remove(customElementStack.length() - 1)
                } else {
                    error("Malformed HTML")
                }

                return
            }

            var last_stack_elem = stack[stack.length() - 1]
            if (tag.name == last_stack_elem.type) {
                if (last_stack_elem.__is_for) {
                    // println("POPPING FOR - ", i)
                    collecting_for_children = false
                }
                stack.remove(stack.length() - 1)
            } else {
                error("Malformed HTML")
            }
        }
    })

    // Let's create the looped elements
    
    looped_elements.forEach((elem, index) => {
        var dependencies = []
        const container = elem.current_parent
        const list = elem.values[0]
        dependencies.append(list)

        const methods_copy = copy(methods)
        methods_copy.remove_prop("setup")
        methods_copy.remove_prop("before")
        methods_copy.remove_prop("init")

        if (elem.values.length() == 1) {
            wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")

            data[list].forEach((v) => {
                var tags = elem.children
                var e = createElement(tags, data, (data) => methods_copy, custom, components)
                wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")
            })
        } else if (elem.values.length() == 2) {
            var iterator = elem.values[1].trim()

            const current_iterator_variable = data[iterator]

            wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")

            data[list].forEach((v) => {
                data[iterator] = v
                var tags = elem.children
                var e = createElement(tags, data, (data) => methods_copy, custom, components)
                wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")

                if (current_iterator_variable) {
                    data[iterator] = current_iterator_variable
                } else {
                    data.remove_prop(iterator)
                }
            })
        } else if (elem.values.length() == 3) {
            var iterator = elem.values[1].trim()
            var index_var = elem.values[2].trim()

            const current_iterator_variable = data[iterator]
            const current_index_variable = data[index_var]

            wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")

            data[list].forEach((v, i) => {
                data[iterator] = v
                data[index_var] = i
                var tags = elem.children
                var e = createElement(tags, data, (data) => methods_copy, custom, components)
                wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")

                if (current_iterator_variable) {
                    data[iterator] = current_iterator_variable
                } else {
                    data.remove_prop(iterator)
                }

                if (current_index_variable) {
                    data[index_var] = current_index_variable
                } else {
                    data.remove_prop(index_var)
                }
            })
        }

        const current_onchange = data[list].info().onChangeHook

        data[list]::onChange((e) => {

            if (current_onchange) {
                current_onchange(e)
            }

            if (elem.values.length() == 1) {
                wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")
    
                data[list].forEach((v) => {
                    var tags = elem.children
                    var e = createElement(tags, data, (data) => methods_copy, custom, components)
                    wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")
                })
            } else if (elem.values.length() == 2) {
                var iterator = elem.values[1].trim()
    
                const current_iterator_variable = data[iterator]
    
                wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")
    
                data[list].forEach((v) => {
                    data[iterator] = v
                    var tags = elem.children
                    var e = createElement(tags, data, (data) => methods_copy, custom, components)
                    wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")
    
                    if (current_iterator_variable) {
                        data[iterator] = current_iterator_variable
                    } else {
                        data.remove_prop(iterator)
                    }
                })
            } else if (elem.values.length() == 3) {
                var iterator = elem.values[1].trim()
                var index_var = elem.values[2].trim()
    
                const current_iterator_variable = data[iterator]
                const current_index_variable = data[index_var]
    
                wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")
    
                data[list].forEach((v, i) => {
                    data[iterator] = v
                    data[index_var] = i
                    var tags = elem.children
                    var e = createElement(tags, data, (data) => methods_copy, custom, components)
                    wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")
    
                    if (current_iterator_variable) {
                        data[iterator] = current_iterator_variable
                    } else {
                        data.remove_prop(iterator)
                    }
    
                    if (current_index_variable) {
                        data[index_var] = current_index_variable
                    } else {
                        data.remove_prop(index_var)
                    }
                })
            }

            // var iterator = elem.values[1].trim()

            // const current_iterator_variable = data[iterator]

            // wasm.run_script(f"document.getElementById('${container.id}').innerHTML = ''")

            // data[list].forEach((v) => {
            //     data[iterator] = v
            //     var tags = elem.children
            //     var e = createElement(tags, data, (data) => methods_copy, custom, components)
            //     wasm.run_script(f"document.getElementById('${container.id}').appendChild(document.getElementById('${e.id}'))")


            //     if (current_iterator_variable) {
            //         data[iterator] = current_iterator_variable
            //     } else {
            //         data.remove_prop(iterator)
            //     }
            // })
        })
    })

    // End loops
    if (methods.init) {
        const arity = methods.init.info().arity
        if (arity == 0) {
            methods.init()
        } else if (arity == 1) {
            methods.init(parent)
        }
    }

    return parent
}

const component = (html, data = {}, methods = (data) => ({}), components = {}) => {
    return const component_create = (props = {}, extra_data = {}) => {
        var _data = {...copy(data), __parent: extra_data}
        _data.__id = uuid()
        return createElement(html, _data, methods, props, components)
    }
}