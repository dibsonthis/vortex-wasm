import [component, value, emit_event, event, ref, attribute] : "../../lib/whirlwind"

const template = f`
    <style>
    .btn {
        padding: 10px;
        margin: 5px;
        color: white;
        border-radius: 10px;
        border: none;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease-in-out;
    }

    #decrButton {
        &:hover {
            background-color: red !important;
        }
    }

    #incrButton {
        &:hover {
            background-color: green !important;
        }
    }

    </style>

    <div>
        <h2> Reactivity with Hooks </h2>
        <p $fontSize: "18px" $fontWeight: 400> 
            Whirlwind achieves reactivity using Vortex hooks. Hooks are controlled side-effects that fire when a value is either accessed (onAccess hook) or changed (onChange hook).
        </p>
        <p $fontSize: "18px" $fontWeight: 400> 
            Consider the following simple example. In our code, we have a value named 'count' and two methods that modify that value. 
        </p>
        <p $fontSize: "18px" $fontWeight: 400> 
            We'll create an element that references that value. Whirlwind knows that this element is now bound to this value, and re-renders it whenever it changes. Give it a go:
        </p>
        <div 
            $width: 200px 
            $margin: "0 auto" 
            $border: "5px solid #213780"
            $borderRadius: 15px
            $fontSize: 32px 
            $color: #213780 
            $fontWeight: bold
            $marginBottom: 10px
            $marginTop: 20px
        > 
            {{ count }} 
        </div>
        <button #incrButton @click: incrCount className: btn $backgroundColor: #2a591f> Increase </button>
        <button #decrButton @click: decrCount className: btn $backgroundColor: #802121> Decrease </button>

        <p $fontSize: "18px" $fontWeight: 400> 
            In the above example, reactive hooks were fired when a click event is dispatched. Reactive hooks can fire for other events too, for example:
        </p>

        <h3> 
            OnInput
        </h3>
        <input #exampleInput1 @input: updateValue />
        <p> {{ inputValue }} </p>

        <h3> 
            OnBlur
        </h3>
        <input #exampleInput2 @blur: updateValue2 />
        <p> {{ inputValue2 }} </p>

        <h3> 
            onMouseEnter, onMouseLeave and onMouseMove
        </h3>
        <p> {{ enterValue }} </p>
        <div 
            #mouseExampleBox
            $margin: "0 auto" 
            $width: 200px 
            $height: 100px 
            $border: "5px solid white" 
            $backgroundColor: black
            $cursor: crosshair
            @enter: toggleBoxColor
            @leave: toggleBoxColor
            @move: updateMousePos
        />
        <p %if: inBox> Your mouse is at ({{xPos}}, {{yPos}}) </p>

        <h3 $marginTop: 30px> 
            Custom Events
        </h3>
        <div %if: showModal>
            <Modal title: "Hello, friend" @close: closeModal>
                <p $fontWeight: bold $color: black> Your last mouse position was ({{xPos}}, {{yPos}}) </p>
            </Modal>
        </div>
        <p> Sometimes we want to be able to emit and handle custom events from one component to another. Whirlwind allows you to do that using the 'emit_event' function:</p>

        <button @click: showModal className: btn $backgroundColor: green> Show Modal </button>

        <p> When the user clicks on the modal's backdrop, or the close button, the modal emits a custom close event that's then handled by the parent component. The parent component receives the event and changes the 'showModal' value to false.</p>
        
    </div>
`

import [Modal] : "../Modal/Modal"

const inputValueDefault = "Enter text above to update me"
const inputValueDefault2 = "Enter text above and click away to update me"

const data = {
    count: 0,
    inputValue: inputValueDefault,
    inputValue2: inputValueDefault2,
    enterValue: "Move your cursor inside the box",
    inBox: false,
    xPos: 0,
    yPos: 0,
    showModal: false
}

const methods = (data) => ({
    incrCount: () => {
        data.count += 1
    },
    decrCount: () => {
        data.count -= 1
    },
    updateValue: (parent) => {
        var value = event().target.value
        data.inputValue = value != "" and value or inputValueDefault
    },
    updateValue2: (parent) => {
        var value = event().target.value
        data.inputValue2 = value != "" and value or inputValueDefault2
    },
    toggleBoxColor: (parent) => {
        const currentColor = parent.mouseExampleBox.attribute("style.backgroundColor");
        var newColor;
        if (currentColor == "black") {
            data.enterValue = "You have entered the box"
            data.inBox = true
            newColor = "red"
        } else {
            data.enterValue = "You have exited the box"
            data.inBox = false
            newColor = "black"
        }
        parent.mouseExampleBox.update({
            style: {
                backgroundColor: newColor
            }
        })
    },
    updateMousePos: () => {
        data.xPos = event().x
        data.yPos = event().y
    },
    showModal: () => {
        data.showModal = true
    },
    closeModal: () => {
        data.showModal = false
    }
})

const components = {
    Modal: Modal
}

const Reactivity = component(template, data, methods, components)