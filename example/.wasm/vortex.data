import io
import math
import sdl
import [] : string
import [] : logging
import [run_script, make_closure, delete_closure] : wasm

const logger = Logger("SDL")
logger.setBaseLogLevel(LogLevels.DEBUG)
logger.setFilePath("sdl.debug")
logger.setFormat("%name%: [%level%] %message% - %day%/%month%/%year%T%hh%:%mm%")

const vec3 = (x = 0, y = 0, z = 0) => {
    return {x: x, y: y, z: z}
}

const triangle = (a, b, c) => {
    return {a: a, b: b, c: c}
}

const loadObject = (filePath) => {
    const src = io.readf(filePath)
    const lines = src.split("\n")

    var vecs = []
    var triangles = []

    for (lines, i, line) {
        if (line[0] == "v") {
            const vecLine = line.split()
            var vec = vec3(vecLine[1].number(), vecLine[2].number(), vecLine[3].number())
            vecs.append(vec)
        } else if (line[0] == "f") {
            const fLine = line.split()
            var tri = triangle(vecs[fLine[1].number() - 1], vecs[fLine[2].number() - 1], vecs[fLine[3].number() - 1])
            triangles.append(tri)
        }
    }

   return { triangles: triangles }
}

var init = sdl.initSDL()

if (init != 0) {
  print("Error initializing SDL\n")
  exit(1)
} else {
  print("Initialized SDL\n")
}

const window = sdl.createWindow("Test", 300, 100, 600, 400)
const renderer = sdl.createRenderer(window)

var running = true
var debug = false
var xPos = 0
var yPos = 0

var x = {
    value: 100
}

/* Game Vars */

var cube = {}

cube.triangles = [
    // South
    triangle(vec3(0, 0, 0), vec3(0, 1, 0), vec3(1, 1, 0)),
    triangle(vec3(0, 0, 0), vec3(1, 1, 0), vec3(1, 0, 0)),

    // East
    triangle(vec3(1, 0, 0), vec3(1, 1, 0), vec3(1, 1, 1)),
    triangle(vec3(1, 0, 0), vec3(1, 1, 1), vec3(1, 0, 1)),

    // North
    triangle(vec3(1, 0, 1), vec3(1, 1, 1), vec3(0, 1, 1)),
    triangle(vec3(1, 0, 1), vec3(0, 1, 1), vec3(0, 0, 1)),

    // West
    triangle(vec3(0, 0, 1), vec3(0, 1, 1), vec3(0, 1, 0)),
    triangle(vec3(0, 0, 1), vec3(0, 1, 0), vec3(0, 0, 0)),

    // Top
    triangle(vec3(0, 1, 0), vec3(0, 1, 1), vec3(1, 1, 1)),
    triangle(vec3(0, 1, 0), vec3(1, 1, 1), vec3(1, 1, 0)),

    // Bottom
    triangle(vec3(1, 0, 1), vec3(0, 0, 1), vec3(0, 0, 0)),
    triangle(vec3(1, 0, 1), vec3(0, 0, 0), vec3(1, 0, 0))
]

// var object = loadObject("resources/spaceship.obj")
var object = cube

// Projection Matrix

const fNear = 0.1
const fFar = 1000
const fFov = 100
const fAspectRatio = sdl.getWindowSize(window).h / sdl.getWindowSize(window).w
const fFovRad = 1 / math.tan(fFov * 0.5 / 180 * 3.14)
var fTheta = 0

var distance = 3
var rotation_factor = 0.05

var vCamera = { x: 0, y: 0, z: 0 }

const matProj = [
    [fAspectRatio * fFovRad, 0, 0, 0],
    [0, fFovRad, 0, 0],
    [0, 0, fFar / (fFar - fNear), 1],
    [0, 0, (-fFar * fNear) / (fFar - fNear), 0]
]

const multMat4 = (vec, mat) => {
    var vecOut = math.multMat4(vec, mat)

    // var vecOut = {
    //     x: vec.x * mat[0][0] + vec.y * mat[1][0] + vec.z * mat[2][0] + mat[3][0],
    //     y: vec.x * mat[0][1] + vec.y * mat[1][1] + vec.z * mat[2][1] + mat[3][1],
    //     z: vec.x * mat[0][2] + vec.y * mat[1][2] + vec.z * mat[2][2] + mat[3][2]
    // }

    // const w = vec.x * mat[0][3] + vec.y * mat[1][3] + vec.z * mat[2][3] + mat[3][3]

    // if (w != 0) {
    //     vecOut.x = vecOut.x / w;
    //     vecOut.y = vecOut.y / w;
    //     vecOut.z = vecOut.z / w;
    // }

    return vecOut
}

const drawTriangle = (renderer, x1, y1, x2, y2, x3, y3, color) => {
    sdl.setRenderDrawColor(renderer, color.r, color.g, color.b, color.a)
    sdl.drawLine(renderer, x1, y1, x2, y2)
    sdl.drawLine(renderer, x2, y2, x3, y3)
    sdl.drawLine(renderer, x3, y3, x1, y1)
}

const fillTriangle = (renderer, x1, y1, x2, y2, x3, y3, color) => {
    sdl.setRenderDrawColor(renderer, color.r, color.g, color.b, color.a)
    sdl.drawGeometry(renderer, [
        {color: color, position: vec3(x1, y1, 0)},
        {color: color, position: vec3(x2, y2, 0)},
        {color: color, position: vec3(x3, y3, 0)}
    ])
}

const onQuit = () => {
    logger.info("Quit SDL")
  print("Done\n")
  running = false
}

const onMouseDown = (event) => {
}

const onMouseUp = (event) => {
}

const onKeyDown = (event) => {
  const keyStr = sdl.getKeyName(event.key.keysm.sym)
  if (keyStr == "Escape") {
    onQuit()
  }
    if (keyStr == "D") {
        logger.info("Debug: " + string(debug))
        debug = !debug
    }
    if (keyStr == "W") {
        rotation_factor += 0.05
    }
    if (keyStr == "Q") {
        rotation_factor -= 0.05
    }
    if (keyStr == "S") {
        distance += 0.5
    }
    if (keyStr == "A") {
        distance -= 0.5
    }
}

const onKeyUp = (event) => {
}

const onMouseMotion = (event) => {
  xPos = event.motion.x
  yPos = event.motion.y
}

const main = () => {
  var status;
  while (status != 0) {
      const poll = sdl.pollEvent()
      status = poll.status
      const event = poll.event

      if (event.type == sdl.EventType.QUIT) {
          onQuit()
      }
      if (event.type == sdl.EventType.MOUSEBUTTONDOWN) {
        println("Clicked")
        onMouseDown(event)
      }
      if (event.type == sdl.EventType.MOUSEBUTTONUP) {
        onMouseUp(event)
      }
      if (event.type == sdl.EventType.MOUSEMOTION) {
        onMouseMotion(event)
      }
      if (event.type == sdl.EventType.KEYDOWN) {
        onKeyDown(event)
      }
      if (event.type == sdl.EventType.KEYUP) {
        onKeyUp(event)
      }
    }

    sdl.renderClear(renderer)

  /* Render */

  fTheta += rotation_factor

  const matRotZ = [
      [math.cos(fTheta), math.sin(fTheta), 0, 0],
      [-math.sin(fTheta), math.cos(fTheta), 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
  ]

  const matRotX = [
      [1, 0, 0, 0],
      [0, math.cos(fTheta * 0.5), math.sin(fTheta * 0.5), 0],
      [0, -math.sin(fTheta * 0.5), math.cos(fTheta * 0.5), 0],
      [0, 0, 0, 1]
  ]

  var trianglesToRender = []

  for (object.triangles, i, tri) {

      var object_color = { r: 200, g: x.value, b: 120, a: 255 }

      var rotatedTri = copy(tri)

      rotatedTri.a = multMat4(rotatedTri.a, matRotZ)
      rotatedTri.b = multMat4(rotatedTri.b, matRotZ)
      rotatedTri.c = multMat4(rotatedTri.c, matRotZ)

      rotatedTri.a = multMat4(rotatedTri.a, matRotX)
      rotatedTri.b = multMat4(rotatedTri.b, matRotX)
      rotatedTri.c = multMat4(rotatedTri.c, matRotX)

      var translatedTri = rotatedTri

      translatedTri.a.z += distance
      translatedTri.b.z += distance
      translatedTri.c.z += distance

      // Extract Normal

      const line1 = {
          x: translatedTri.b.x - translatedTri.a.x,
          y: translatedTri.b.y - translatedTri.a.y,
          z: translatedTri.b.z - translatedTri.a.z,
      }

      const line2 = {
          x: translatedTri.c.x - translatedTri.a.x,
          y: translatedTri.c.y - translatedTri.a.y,
          z: translatedTri.c.z - translatedTri.a.z,
      }

      var normal = {
          x: line1.y * line2.z - line1.z * line2.y,
          y: line1.z * line2.x - line1.x * line2.z,
          z: line1.x * line2.y - line1.y * line2.x,
      }

      // Normalise Normal

      const l = math.sqrt((normal.x ^ 2) + (normal.y ^ 2) + (normal.z ^ 2))
      normal.x = normal.x / l
      normal.y = normal.y / l
      normal.z = normal.z / l

      const normal_dot_product = 
          normal.x * (translatedTri.a.x - vCamera.x) +
          normal.y * (translatedTri.a.y - vCamera.y) +
          normal.z * (translatedTri.a.z - vCamera.z)

      if (normal_dot_product < 0) {

          // Basic light

          var vLight = { x: 0, y: 0, z: -1 }

          const lightNormaliser = math.sqrt((vLight.x ^ 2) + (vLight.y ^ 2) + (vLight.z ^ 2))
          vLight.x = vLight.x / lightNormaliser
          vLight.y = vLight.y / lightNormaliser
          vLight.z = vLight.z / lightNormaliser

          const light_dot_product = 
          normal.x * (vLight.x - vCamera.x) +
          normal.y * (vLight.y - vCamera.y) +
          normal.z * (vLight.z - vCamera.z)

          // Projection

          var projectedTri = {
              a: multMat4(translatedTri.a, matProj),
              b: multMat4(translatedTri.b, matProj),
              c: multMat4(translatedTri.c, matProj)
          }

          // Scale

          projectedTri.a.x += 1
          projectedTri.a.y += 1
          projectedTri.b.x += 1
          projectedTri.b.y += 1
          projectedTri.c.x += 1
          projectedTri.c.y += 1

          projectedTri.a.x = projectedTri.a.x * 0.5 * sdl.getWindowSize(window).w
          projectedTri.a.y = projectedTri.a.y * 0.5 * sdl.getWindowSize(window).h
          projectedTri.b.x = projectedTri.b.x * 0.5 * sdl.getWindowSize(window).w
          projectedTri.b.y = projectedTri.b.y * 0.5 * sdl.getWindowSize(window).h
          projectedTri.c.x = projectedTri.c.x * 0.5 * sdl.getWindowSize(window).w
          projectedTri.c.y = projectedTri.c.y * 0.5 * sdl.getWindowSize(window).h

          projectedTri.color = {r: light_dot_product * object_color.r, g: light_dot_product * object_color.g, b: light_dot_product * object_color.b, a: 255}

          trianglesToRender.append(projectedTri)
      }
  }

  trianglesToRender = trianglesToRender.sort((t1, t2) => {
      const z1 = (t1.a.z + t1.b.z + t1.c.z) / 3
      const z2 = (t2.a.z + t2.b.z + t2.c.z) / 3
      return z1 > z2
  })

  for (trianglesToRender, i, tri) {

      fillTriangle(
          renderer,
          tri.a.x, tri.a.y,
          tri.b.x, tri.b.y,
          tri.c.x, tri.c.y,
          tri.color
      )

      if (debug) {
          drawTriangle(
              renderer,
              tri.a.x, tri.a.y,
              tri.b.x, tri.b.y,
              tri.c.x, tri.c.y,
              {r: 255, g: 255, b: 255, a: 255}
          )
      }
  }

  sdl.setRenderDrawColor(renderer, 0, 0, 0, 255)

  sdl.renderPresent(renderer)

  //sdl.delay(20)
}

// import [run_script, make_closure, delete_closure] : wasm
// import math 
import random

const button = (config = {}) => {
    var _btn = {
        _id: "",
        id: "",
        onClick: None,
        title: "",
        style: (property, value) => {
            run_script(f"document.getElementById('${this.id}').style.${property} = '${value}'")
        },
        styles: (config) => {
            if (config.type() != "Object") {
                return
            }

            var script = f"const _ = document.getElementById('${this.id}');"

            for (config.info().keys, index, key) {
                script += f"_.style.${key} = '${config[key]}';"
            }

            run_script(script)
        }
    }
    const _id = "button_" + string(math.abs(random.rand()))
    _btn._id = _id
    var script = f"var ${_id} = document.createElement('button');"
    if (config.id) {
        _btn.id = config.id
        script += f"${_id}.id = '${config.id}';"
    }
    if (config.title) {
        _btn.title = config.title
        script += f"${_id}.innerHTML = '${config.title}';"
    }
    if (config.onClick) {
        _btn.onClick = make_closure(config.onClick)
        script += f"${_id}.onclick = function() {
            Module.ccall('vortex_eval','void',['number'],[${_btn.onClick}]);
        };"
    }

    script += f"document.body.appendChild(${_id});"

    run_script(script)

    _btn.title::onChange((e) => {
        run_script(f"document.getElementById('${_btn.id}').innerHTML = '${e.current}'")
    })

    _btn.onClick::onChange((e) => {
        _btn.onClick = make_closure(e.current)
        e.current = _btn.onClick
        delete_closure(e.old)
        run_script(f"document.getElementById('${_btn.id}').onclick = function() {
            Module.ccall('vortex_eval','void',['number'],[${_btn.onClick}]);
        };")
    })

    return _btn
}

const createCSSClass = (className, css) => {
    const _id = "style_" + string(math.abs(random.rand()))
    var script = f"var ${_id} = document.createElement('style');"
    script += f"${_id}.type = 'text/css';"
    script += f"${_id}.innerHTML = '.${className} { ${css} }';"
    script += f"document.head.appendChild(${_id});"

    run_script(script)
}

const addCSSClass = (id, className) => {
    run_script(f"document.getElementById('${id}').classList.add('${className}');")
}

const removeCSSClass = (id, className) => {
    run_script(f"document.getElementById('${id}').classList.remove('${className}');")
}

createCSSClass("incr-btn", "
    transition: 300ms all ease-in-out;
    &:hover {
        background-color: #3E95FF !important;
    }
")

createCSSClass("decr-btn", "
    transition: 300ms all ease-in-out;
    &:hover {
        background-color: #AE0000 !important;
    }
")

createCSSClass("switch-btn", "
    font-size: 16px; 
    background-color: #08887C; 
    color: white;
    border-radius: 5px;
    border: none;
    padding: 10px;
    box-shadow: 0 3px 5px rgba(0, 0, 0, 0.18);
    cursor: pointer;
    transition: 220ms all ease-in-out;
    &:hover {
        background-color: #098808;
      }
")

const incr_fn = () => {
    x.value += 1
}

const decr_fn = () => {
    x.value -= 1
}

var b = button({
    title: "Increment",
    id: "incr",
    onClick: () => {
        incr_fn()
        println(x.value)
    }
})

const button_styles = {
    padding: "1em 1.5em",
    backgroundColor: "#3e68ff",
    color: "#fff",
    margin: "5px",
    fontSize: "18px",
    fontWeight: "bold",
    borderRadius: "15px",
    border: "none",
    boxSizing: "border-box",
    cursor: "pointer",
    fontFamily: "inherit",
    boxShadow: "0 3px 5px rgba(0, 0, 0, 0.18)",
    textAlign: "center",
    width: "150px"
}

b.styles(button_styles)
addCSSClass(b.id, "incr-btn")

const b2 = button({
    id: "switch",
    title: "Switch",
    onClick: () => {
        if (b.title == "Increment") {
            b.title = "Decrement"
            b.style("backgroundColor", "red")
            b.onClick = () => {
                decr_fn()
                println(x.value)
            }
            removeCSSClass(b.id, "incr-btn")
            addCSSClass(b.id, "decr-btn")
        } else {
            b.title = "Increment"
            b.styles(button_styles)
            b.onClick = () => {
                incr_fn()
                println(x.value)
            }
            removeCSSClass(b.id, "decr-btn")
            addCSSClass(b.id, "incr-btn")
        }
    }
})

addCSSClass(b2.id, "switch-btn")

println(10.94)

sdl.wasm_main_loop(main, true)